diff --git a/node_modules/@librechat/agents/dist/cjs/common/enum.cjs b/node_modules/@librechat/agents/dist/cjs/common/enum.cjs
index 48eb5ed..574f874 100644
--- a/node_modules/@librechat/agents/dist/cjs/common/enum.cjs
+++ b/node_modules/@librechat/agents/dist/cjs/common/enum.cjs
@@ -23,6 +23,7 @@ exports.GraphEvents = void 0;
     GraphEvents["ON_REASONING_DELTA"] = "on_reasoning_delta";
     /** [Custom] Request to execute tools - dispatched by ToolNode, handled by host */
     GraphEvents["ON_TOOL_EXECUTE"] = "on_tool_execute";
+    GraphEvents["ON_HANDOFF"] = "on_handoff";
     /* Official Events */
     /** Custom event, emitted by system */
     GraphEvents["ON_CUSTOM_EVENT"] = "on_custom_event";
diff --git a/node_modules/@librechat/agents/dist/cjs/tools/ToolNode.cjs b/node_modules/@librechat/agents/dist/cjs/tools/ToolNode.cjs
index 3742cf2..f7aadb8 100644
--- a/node_modules/@librechat/agents/dist/cjs/tools/ToolNode.cjs
+++ b/node_modules/@librechat/agents/dist/cjs/tools/ToolNode.cjs
@@ -374,11 +374,16 @@ class ToolNode extends run.RunnableCallable {
     async run(input, config) {
         let outputs;
         if (this.isSendInput(input)) {
-            const isDirectTool = this.directToolNames?.has(input.lg_tool_call.name);
+            const call = input.lg_tool_call;
+            const isDirectTool = this.directToolNames?.has(call.name);
             if (this.eventDrivenMode && isDirectTool !== true) {
-                return this.executeViaEvent([input.lg_tool_call], config, input);
+                return this.executeViaEvent([call], config, input);
             }
-            outputs = [await this.runTool(input.lg_tool_call, config)];
+            const output = await this.runTool(call, config);
+            if (langgraph.isCommand(output) && typeof output.goto === 'string' && typeof call.name === 'string' && call.name.startsWith(_enum.Constants.LC_TRANSFER_TO_)) {
+                events.safeDispatchCustomEvent(_enum.GraphEvents.ON_HANDOFF, { toolName: call.name, destinationAgentId: output.goto }, config);
+            }
+            outputs = [output];
         }
         else {
             let messages$1;
@@ -430,6 +435,13 @@ class ToolNode extends run.RunnableCallable {
                 const directOutputs = directCalls.length > 0
                     ? await Promise.all(directCalls.map((call) => this.runTool(call, config)))
                     : [];
+                for (let i = 0; i < directCalls.length; i++) {
+                    const call = directCalls[i];
+                    const output = directOutputs[i];
+                    if (call && output && langgraph.isCommand(output) && typeof output.goto === 'string' && typeof call.name === 'string' && call.name.startsWith(_enum.Constants.LC_TRANSFER_TO_)) {
+                        events.safeDispatchCustomEvent(_enum.GraphEvents.ON_HANDOFF, { toolName: call.name, destinationAgentId: output.goto }, config);
+                    }
+                }
                 const eventOutputs = eventCalls.length > 0
                     ? await this.dispatchToolEvents(eventCalls, config)
                     : [];
diff --git a/node_modules/@librechat/agents/dist/esm/common/enum.mjs b/node_modules/@librechat/agents/dist/esm/common/enum.mjs
index c6781ea..4a241ce 100644
--- a/node_modules/@librechat/agents/dist/esm/common/enum.mjs
+++ b/node_modules/@librechat/agents/dist/esm/common/enum.mjs
@@ -21,6 +21,7 @@ var GraphEvents;
     GraphEvents["ON_REASONING_DELTA"] = "on_reasoning_delta";
     /** [Custom] Request to execute tools - dispatched by ToolNode, handled by host */
     GraphEvents["ON_TOOL_EXECUTE"] = "on_tool_execute";
+    GraphEvents["ON_HANDOFF"] = "on_handoff";
     /* Official Events */
     /** Custom event, emitted by system */
     GraphEvents["ON_CUSTOM_EVENT"] = "on_custom_event";
diff --git a/node_modules/@librechat/agents/dist/esm/tools/ToolNode.mjs b/node_modules/@librechat/agents/dist/esm/tools/ToolNode.mjs
index 608cd71..d31cbc1 100644
--- a/node_modules/@librechat/agents/dist/esm/tools/ToolNode.mjs
+++ b/node_modules/@librechat/agents/dist/esm/tools/ToolNode.mjs
@@ -372,11 +372,16 @@ class ToolNode extends RunnableCallable {
     async run(input, config) {
         let outputs;
         if (this.isSendInput(input)) {
-            const isDirectTool = this.directToolNames?.has(input.lg_tool_call.name);
+            const call = input.lg_tool_call;
+            const isDirectTool = this.directToolNames?.has(call.name);
             if (this.eventDrivenMode && isDirectTool !== true) {
-                return this.executeViaEvent([input.lg_tool_call], config, input);
+                return this.executeViaEvent([call], config, input);
             }
-            outputs = [await this.runTool(input.lg_tool_call, config)];
+            const output = await this.runTool(call, config);
+            if (isCommand(output) && typeof output.goto === 'string' && typeof call.name === 'string' && call.name.startsWith(Constants.LC_TRANSFER_TO_)) {
+                safeDispatchCustomEvent(GraphEvents.ON_HANDOFF, { toolName: call.name, destinationAgentId: output.goto }, config);
+            }
+            outputs = [output];
         }
         else {
             let messages;
@@ -428,6 +433,13 @@ class ToolNode extends RunnableCallable {
                 const directOutputs = directCalls.length > 0
                     ? await Promise.all(directCalls.map((call) => this.runTool(call, config)))
                     : [];
+                for (let i = 0; i < directCalls.length; i++) {
+                    const call = directCalls[i];
+                    const output = directOutputs[i];
+                    if (call && output && isCommand(output) && typeof output.goto === 'string' && typeof call.name === 'string' && call.name.startsWith(Constants.LC_TRANSFER_TO_)) {
+                        safeDispatchCustomEvent(GraphEvents.ON_HANDOFF, { toolName: call.name, destinationAgentId: output.goto }, config);
+                    }
+                }
                 const eventOutputs = eventCalls.length > 0
                     ? await this.dispatchToolEvents(eventCalls, config)
                     : [];
diff --git a/node_modules/@librechat/agents/src/common/enum.ts b/node_modules/@librechat/agents/src/common/enum.ts
index b487271..186d5e8 100644
--- a/node_modules/@librechat/agents/src/common/enum.ts
+++ b/node_modules/@librechat/agents/src/common/enum.ts
@@ -21,6 +21,8 @@ export enum GraphEvents {
   ON_REASONING_DELTA = 'on_reasoning_delta',
   /** [Custom] Request to execute tools - dispatched by ToolNode, handled by host */
   ON_TOOL_EXECUTE = 'on_tool_execute',
+  /** [Custom] Emitted when a direct handoff tool completes - allows host to update handoffState */
+  ON_HANDOFF = 'on_handoff',
 
   /* Official Events */
 
diff --git a/node_modules/@librechat/agents/src/tools/ToolNode.ts b/node_modules/@librechat/agents/src/tools/ToolNode.ts
index 47cd9d9..98c87b5 100644
--- a/node_modules/@librechat/agents/src/tools/ToolNode.ts
+++ b/node_modules/@librechat/agents/src/tools/ToolNode.ts
@@ -479,11 +479,25 @@ export class ToolNode<T = any> extends RunnableCallable<T, T> {
     let outputs: (BaseMessage | Command)[];
 
     if (this.isSendInput(input)) {
-      const isDirectTool = this.directToolNames?.has(input.lg_tool_call.name);
+      const call = input.lg_tool_call;
+      const isDirectTool = this.directToolNames?.has(call.name);
       if (this.eventDrivenMode && isDirectTool !== true) {
-        return this.executeViaEvent([input.lg_tool_call], config, input);
+        return this.executeViaEvent([call], config, input);
       }
-      outputs = [await this.runTool(input.lg_tool_call, config)];
+      const output = await this.runTool(call, config);
+      if (
+        isCommand(output) &&
+        typeof output.goto === 'string' &&
+        typeof call.name === 'string' &&
+        call.name.startsWith(Constants.LC_TRANSFER_TO_)
+      ) {
+        safeDispatchCustomEvent(
+          GraphEvents.ON_HANDOFF,
+          { toolName: call.name, destinationAgentId: output.goto },
+          config
+        );
+      }
+      outputs = [output];
     } else {
       let messages: BaseMessage[];
       if (Array.isArray(input)) {
@@ -557,6 +571,25 @@ export class ToolNode<T = any> extends RunnableCallable<T, T> {
             )
             : [];
 
+        for (let i = 0; i < directCalls.length; i++) {
+          const call = directCalls[i];
+          const output = directOutputs[i];
+          if (
+            call &&
+            output &&
+            isCommand(output) &&
+            typeof output.goto === 'string' &&
+            typeof call.name === 'string' &&
+            call.name.startsWith(Constants.LC_TRANSFER_TO_)
+          ) {
+            safeDispatchCustomEvent(
+              GraphEvents.ON_HANDOFF,
+              { toolName: call.name, destinationAgentId: output.goto },
+              config
+            );
+          }
+        }
+
         const eventOutputs: ToolMessage[] =
           eventCalls.length > 0
             ? await this.dispatchToolEvents(eventCalls, config)
